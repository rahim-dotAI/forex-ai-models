name: Smart Forex Brain Pipeline (Trade Beacon v17.0)

on:
  workflow_dispatch:
  push:
    paths:
      - 'colab_trigger.txt'
    branches:
      - main
  schedule:
    # Weekdays (Mon-Fri): Every 2 hours - Full notebook execution
    - cron: '0 */2 * * 1-5'
    # Weekends (Sat-Sun): Every 30 minutes - Tagged cells only
    - cron: '*/30 * * * 0,6'

jobs:
  run-forex-brain:
    runs-on: ubuntu-latest
    timeout-minutes: 55

    env:
      FOREX_PAT: ${{ secrets.FOREX_PAT }}
      BROWSERLESS_TOKEN: ${{ secrets.BROWSERLESS_TOKEN }}
      ALPHA_VANTAGE_KEY: ${{ secrets.ALPHA_VANTAGE_KEY }}
      GMAIL_USER: ${{ secrets.GMAIL_USER }}
      GMAIL_APP_PASSWORD: ${{ secrets.GMAIL_APP_PASSWORD }}
      GIT_USER_NAME: "Forex AI Bot"
      GIT_USER_EMAIL: "nakatonabira3@gmail.com"
      GITHUB_USERNAME: "rahim-dotAI"
      GITHUB_REPO: "forex-ai-models"
      PYTHONIOENCODING: utf-8
      PYTHONUNBUFFERED: 1
      GITHUB_ACTIONS: "true"
      SINGLE_RUN_MODE: "true"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 0
          lfs: true
          token: ${{ secrets.FOREX_PAT }}

      - name: Fix submodule issue
        run: |
          echo "=========================================="
          echo "ðŸ”§ FIXING SUBMODULE CONFIGURATION"
          echo "=========================================="
          
          if [ -f ".gitmodules" ]; then
            echo "âš ï¸ Found .gitmodules file - removing it"
            rm -f .gitmodules
            git rm --cached -r forex-alpha-models 2>/dev/null || true
            rm -rf forex-alpha-models
            git add .gitmodules 2>/dev/null || true
            echo "âœ… Submodule configuration removed"
          else
            echo "âœ… No .gitmodules file found"
          fi
          
          find . -mindepth 2 -name ".git" -type d -exec rm -rf {} + 2>/dev/null || true
          echo "=========================================="

      - name: Detect Execution Mode
        id: detect_mode
        run: |
          DAY_OF_WEEK=$(date +%u)
          HOUR=$(date +%H)
          
          echo "=========================================="
          echo "ðŸ—“ï¸  EXECUTION MODE DETECTION"
          echo "=========================================="
          echo "Current day: $DAY_OF_WEEK (1=Mon, 5=Fri, 6=Sat, 7=Sun)"
          echo "Current hour: $HOUR UTC"
          echo "Date: $(date +'%A, %B %d, %Y %H:%M UTC')"
          echo ""
          
          # Weekend = Saturday (6) or Sunday (7)
          if [ $DAY_OF_WEEK -eq 6 ] || [ $DAY_OF_WEEK -eq 7 ]; then
            echo "execution_mode=weekend_tagged_cells" >> $GITHUB_OUTPUT
            echo "schedule_type=30min_tagged" >> $GITHUB_OUTPUT
            echo "ðŸ–ï¸ MODE: WEEKEND (Saturday/Sunday)"
            echo "   â€¢ Execution: Tagged cells only"
            echo "   â€¢ Schedule: Every 30 minutes"
            echo "   â€¢ Trading: LEARNING MODE"
          else
            echo "execution_mode=weekday_full_notebook" >> $GITHUB_OUTPUT
            echo "schedule_type=2hourly" >> $GITHUB_OUTPUT
            echo "ðŸ’¼ MODE: WEEKDAY (Monday-Friday)"
            echo "   â€¢ Execution: Full notebook"
            echo "   â€¢ Schedule: Every 2 hours"
            echo "   â€¢ Trading: LIVE MODE"
          fi
          echo "=========================================="

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip

      - name: Install dependencies
        run: |
          echo "ðŸ“¦ Installing Python dependencies..."
          python -m pip install --upgrade pip wheel setuptools
          pip install --no-cache-dir \
            pandas numpy requests beautifulsoup4 scikit-learn \
            jupyter nbconvert nbformat ta yfinance \
            mplfinance firebase-admin dropbox \
            pyppeteer nest_asyncio lightgbm joblib matplotlib \
            alpha_vantage tqdm river scipy
          echo "âœ… Dependencies installed"

      - name: Configure Git
        run: |
          git config --global user.name "${GIT_USER_NAME}"
          git config --global user.email "${GIT_USER_EMAIL}"
          git config --global credential.helper store
          echo "https://${GITHUB_USERNAME}:${FOREX_PAT}@github.com" > ~/.git-credentials
          echo "âœ… Git configured"

      - name: Check for Required Data Files
        id: check_data
        run: |
          echo "=========================================="
          echo "ðŸ” CHECKING FOR REQUIRED DATA FILES"
          echo "=========================================="
          
          PICKLE_COUNT=$(find data/processed -name "*.pkl" -type f 2>/dev/null | \
            grep -v "_sgd_model\|_rf_model\|indicator_cache\|ultra_\|alpha_\|_model.pkl\|\.bak" | wc -l)
          
          PIPELINE_DB_EXISTS=false
          if [ -f "database/memory_v85.db" ]; then
            PIPELINE_DB_EXISTS=true
          fi
          
          RL_STATE_EXISTS=false
          if [ -d "rl_memory" ] && [ -f "rl_memory/experience_replay.pkl" ]; then
            RL_STATE_EXISTS=true
          fi
          
          echo "ðŸ“Š Data Status:"
          echo "   Processed pickles: $PICKLE_COUNT"
          echo "   Pipeline DB: $PIPELINE_DB_EXISTS"
          echo "   RL State: $RL_STATE_EXISTS"
          
          if [ $PICKLE_COUNT -ge 4 ]; then
            echo "has_data=true" >> $GITHUB_OUTPUT
            echo "âœ… SUFFICIENT DATA FOUND"
          else
            echo "has_data=false" >> $GITHUB_OUTPUT
            echo "âš ï¸  INSUFFICIENT DATA"
          fi
          
          echo "=========================================="

      - name: Create Python Executors
        run: |
          # Create the tagged cells executor
          cat > run_tagged_cells.py << 'EOFPYTHON'
          import nbformat
          from nbconvert.preprocessors import ExecutePreprocessor
          import sys, os, time, re
          from datetime import datetime
          
          class TaggedCellExecutor(ExecutePreprocessor):
              def __init__(self, *args, **kwargs):
                  super().__init__(*args, **kwargs)
                  self.tagged_cells = []
                  self.current_cell = 0
                  self.start_time = None
                  self.cell_summaries = []
                  
              def preprocess(self, nb, resources=None, km=None):
                  for idx, cell in enumerate(nb.cells):
                      if cell.cell_type == 'code' and '#TAG: pipeline_main' in cell.source:
                          self.tagged_cells.append(idx)
                  
                  print(f"ðŸ“Š Found {len(self.tagged_cells)} tagged cells")
                  self.start_time = time.time()
                  return super().preprocess(nb, resources, km)
              
              def preprocess_cell(self, cell, resources, cell_index):
                  if cell.cell_type != 'code' or cell_index not in self.tagged_cells:
                      return cell, resources
                  
                  self.current_cell += 1
                  print(f"\n{'='*70}")
                  print(f"ðŸ”„ TAGGED CELL {self.current_cell}/{len(self.tagged_cells)}")
                  print(f"{'='*70}")
                  
                  cell_start = time.time()
                  
                  try:
                      cell, resources = super().preprocess_cell(cell, resources, cell_index)
                      cell_time = time.time() - cell_start
                      
                      # Extract key output lines (not the full code)
                      output_lines = []
                      if cell.outputs:
                          for output in cell.outputs:
                              if output.output_type == 'stream':
                                  text = re.sub(r'\x1b\[[0-9;]*m', '', output.text)
                                  lines = text.strip().split('\n')
                                  # Only show important lines
                                  for line in lines:
                                      if any(marker in line for marker in ['âœ…', 'âš ï¸', 'âŒ', 'ðŸ’°', 'ðŸ§ ', 'ðŸ’¾', 'ðŸ“Š', 'Iteration', 'Mode:', 'COMPLETE', 'Win Rate', 'Total P&L']):
                                          output_lines.append(line)
                              elif output.output_type == 'error':
                                  output_lines.append(f"âŒ ERROR: {output.ename}: {output.evalue}")
                      
                      # Print condensed output
                      if output_lines:
                          print("\nðŸ“‹ Key Output:")
                          for line in output_lines[:30]:  # Limit to 30 most important lines
                              print(f"   {line}")
                          if len(output_lines) > 30:
                              print(f"   ... ({len(output_lines) - 30} more lines)")
                      
                      print(f"\nâœ… Cell {self.current_cell} completed in {cell_time:.1f}s")
                      
                      self.cell_summaries.append({
                          'cell': self.current_cell,
                          'duration': cell_time,
                          'status': 'success',
                          'key_outputs': len(output_lines)
                      })
                      
                  except Exception as e:
                      cell_time = time.time() - cell_start
                      print(f"\nâŒ Cell {self.current_cell} FAILED after {cell_time:.1f}s")
                      print(f"   Error: {str(e)}")
                      self.cell_summaries.append({
                          'cell': self.current_cell,
                          'duration': cell_time,
                          'status': 'failed',
                          'error': str(e)
                      })
                      raise
                  
                  return cell, resources
          
          def run_tagged_cells(notebook_path):
              with open(notebook_path, 'r', encoding='utf-8') as f:
                  nb = nbformat.read(f, as_version=4)
              
              ep = TaggedCellExecutor(timeout=2400, kernel_name='python3', allow_errors=False)
              
              print("="*70)
              print("ðŸš€ STARTING TAGGED CELLS EXECUTION")
              print("="*70)
              
              start = time.time()
              ep.preprocess(nb, {'metadata': {'path': '.'}})
              duration = time.time() - start
              
              # Print summary
              print("\n" + "="*70)
              print("ðŸ“Š EXECUTION SUMMARY")
              print("="*70)
              for summary in ep.cell_summaries:
                  status_icon = "âœ…" if summary['status'] == 'success' else "âŒ"
                  print(f"{status_icon} Cell {summary['cell']}: {summary['duration']:.1f}s - {summary.get('key_outputs', 0)} key outputs")
              print(f"\nâ±ï¸  Total Duration: {duration:.1f}s")
              print("="*70)
              
              return True
          
          if __name__ == "__main__":
              notebook = "AI_Forex_Brain_2.ipynb"
              if not os.path.exists(notebook):
                  print(f"âŒ Notebook not found: {notebook}")
                  sys.exit(1)
              
              try:
                  success = run_tagged_cells(notebook)
                  sys.exit(0 if success else 1)
              except Exception as e:
                  print(f"\nâŒ FATAL ERROR: {str(e)}")
                  sys.exit(1)
          EOFPYTHON
          
          # Create the full notebook executor
          cat > run_full_notebook.py << 'EOFPYTHON'
          import nbformat
          from nbconvert.preprocessors import ExecutePreprocessor
          import sys, os, time, re
          from datetime import datetime
          
          class SummaryExecutor(ExecutePreprocessor):
              def __init__(self, *args, **kwargs):
                  super().__init__(*args, **kwargs)
                  self.cell_count = 0
                  self.start_time = None
                  
              def preprocess(self, nb, resources=None, km=None):
                  print(f"ðŸ“Š Processing {len(nb.cells)} cells...")
                  self.start_time = time.time()
                  return super().preprocess(nb, resources, km)
              
              def preprocess_cell(self, cell, resources, cell_index):
                  if cell.cell_type != 'code':
                      return cell, resources
                  
                  self.cell_count += 1
                  
                  # Only show progress every 5 cells
                  if self.cell_count % 5 == 0:
                      elapsed = time.time() - self.start_time
                      print(f"â³ Progress: {self.cell_count} cells ({elapsed:.0f}s elapsed)")
                  
                  cell, resources = super().preprocess_cell(cell, resources, cell_index)
                  
                  # Only print key outputs from last few cells
                  if cell_index >= len(resources.get('metadata', {}).get('path', [])) - 3:
                      if cell.outputs:
                          for output in cell.outputs:
                              if output.output_type == 'stream':
                                  text = re.sub(r'\x1b\[[0-9;]*m', '', output.text)
                                  lines = text.strip().split('\n')
                                  for line in lines:
                                      if any(marker in line for marker in ['âœ…', 'âš ï¸', 'âŒ', 'ðŸ’°', 'ðŸ§ ', 'COMPLETE', 'Iteration']):
                                          print(f"   {line}")
                  
                  return cell, resources
          
          def run_notebook(notebook_path):
              with open(notebook_path, 'r', encoding='utf-8') as f:
                  nb = nbformat.read(f, as_version=4)
              
              ep = SummaryExecutor(timeout=2400, kernel_name='python3', allow_errors=False)
              
              print("="*70)
              print("ðŸš€ STARTING FULL NOTEBOOK EXECUTION")
              print("="*70)
              
              start = time.time()
              ep.preprocess(nb, {'metadata': {'path': '.'}})
              duration = time.time() - start
              
              print("\n" + "="*70)
              print(f"âœ… COMPLETED: {ep.cell_count} cells in {duration:.1f}s")
              print("="*70)
              
              return True
          
          if __name__ == "__main__":
              notebook = "AI_Forex_Brain_2.ipynb"
              if not os.path.exists(notebook):
                  print(f"âŒ Notebook not found: {notebook}")
                  sys.exit(1)
              
              try:
                  success = run_notebook(notebook)
                  sys.exit(0 if success else 1)
              except Exception as e:
                  print(f"\nâŒ FATAL ERROR: {str(e)}")
                  sys.exit(1)
          EOFPYTHON
          
          echo "âœ… Python executors created"

      - name: Run Weekend Tagged Cells (Weekend Mode)
        if: steps.detect_mode.outputs.execution_mode == 'weekend_tagged_cells'
        run: |
          echo "=========================================="
          echo "ðŸ–ï¸ WEEKEND MODE: TAGGED CELLS EXECUTION"
          echo "=========================================="
          echo "Day: $(date +'%A')"
          echo "Executing: Tagged cells only (#TAG: pipeline_main)"
          echo ""
          
          python run_tagged_cells.py "AI_Forex_Brain_2.ipynb"
          
          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "âŒ Tagged cell execution failed with code $EXIT_CODE"
            exit $EXIT_CODE
          fi
          
          echo ""
          echo "âœ… Tagged cell execution completed successfully"
        timeout-minutes: 50

      - name: Run Full Notebook (Weekday Mode)
        if: steps.detect_mode.outputs.execution_mode == 'weekday_full_notebook'
        run: |
          echo "=========================================="
          echo "ðŸ’¼ WEEKDAY MODE: FULL NOTEBOOK EXECUTION"
          echo "=========================================="
          echo ""
          
          python run_full_notebook.py "AI_Forex_Brain_2.ipynb"
          
          EXIT_CODE=$?
          if [ $EXIT_CODE -ne 0 ]; then
            echo "âŒ Notebook execution failed with code $EXIT_CODE"
            exit $EXIT_CODE
          fi
          
          echo ""
          echo "âœ… Notebook execution completed successfully"
        timeout-minutes: 50

      - name: Verify output files
        if: always()
        run: |
          echo "=========================================="
          echo "ðŸ“‹ CHECKING OUTPUT FILES"
          echo "=========================================="
          
          for dir in outputs data/processed logs database rl_memory rl_models omega_state; do
            if [ -d "$dir" ]; then
              FILE_COUNT=$(find "$dir" -type f 2>/dev/null | wc -l)
              echo "  âœ… $dir/ ($FILE_COUNT files)"
            fi
          done
          
          echo "=========================================="

      - name: Clean up nested repositories
        if: always()
        run: |
          find . -mindepth 2 -type d -name ".git" -exec rm -rf {} + 2>/dev/null || true
          echo "âœ… Cleanup complete"

      - name: Commit and push changes
        if: always()
        run: |
          git add -A
          
          if git diff --cached --quiet; then
            echo "â„¹ï¸  No changes to commit"
          else
            TIMESTAMP=$(date +'%Y-%m-%d %H:%M UTC')
            DAY=$(date +'%A')
            MODE="${{ steps.detect_mode.outputs.execution_mode }}"
            
            if [ "$MODE" = "weekend_tagged_cells" ]; then
              COMMIT_MSG="ðŸ–ï¸ Trade Beacon v17.0 [Weekend Learning] - $DAY: $TIMESTAMP"
            else
              COMMIT_MSG="ðŸ”´ Trade Beacon v17.0 [Live Trading] - $DAY: $TIMESTAMP"
            fi
            
            git commit -m "$COMMIT_MSG" || true
            
            for i in {1..3}; do
              if git push origin main 2>&1; then
                echo "âœ… Pushed on attempt $i"
                break
              else
                if [ $i -lt 3 ]; then
                  sleep 3
                  git pull --rebase origin main
                fi
              fi
            done
          fi

      - name: Upload logs and artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: execution-logs-${{ github.run_number }}
          path: |
            run_full_notebook.py
            run_tagged_cells.py
            logs/*.log
          retention-days: 7
          if-no-files-found: ignore

      - name: Execution Summary
        if: always()
        run: |
          echo "=========================================="
          echo "ðŸ“Š EXECUTION SUMMARY"
          echo "=========================================="
          echo "Mode: ${{ steps.detect_mode.outputs.execution_mode }}"
          echo "Day: $(date +'%A')"
          echo "Time: $(date +'%B %d, %Y %H:%M UTC')"
          echo "=========================================="
          echo "âœ… Pipeline execution completed"
          echo "=========================================="
