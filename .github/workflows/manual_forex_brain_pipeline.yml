name: Smart Forex Brain Pipeline (Weekday Full / Weekend Tagged)

on:
  workflow_dispatch:
  push:
    paths:
      - 'colab_trigger.txt'
    branches:
      - main
  schedule:
    - cron: '0 */4 * * *'

jobs:
  run-forex-brain:
    runs-on: ubuntu-latest
    timeout-minutes: 55

    env:
      FOREX_PAT: ${{ secrets.FOREX_PAT }}
      BROWSERLESS_TOKEN: ${{ secrets.BROWSERLESS_TOKEN }}
      ALPHA_VANTAGE_KEY: ${{ secrets.ALPHA_VANTAGE_KEY }}
      GMAIL_USER: ${{ secrets.GMAIL_USER }}
      GMAIL_APP_PASSWORD: ${{ secrets.GMAIL_APP_PASSWORD }}
      GIT_USER_NAME: "Forex AI Bot"
      GIT_USER_EMAIL: "nakatonabira3@gmail.com"
      GITHUB_USERNAME: "rahim-dotAI"
      GITHUB_REPO: "forex-ai-models"
      PYTHONIOENCODING: utf-8
      PYTHONUNBUFFERED: 1
      GITHUB_ACTIONS: "true"
      SINGLE_RUN_MODE: "true"

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 0
          lfs: true
          token: ${{ secrets.FOREX_PAT }}

      - name: Detect Weekend vs Weekday Mode
        id: detect_mode
        run: |
          DAY_OF_WEEK=$(date +%u)
          
          echo "=========================================="
          echo "üóìÔ∏è  DAY DETECTION"
          echo "=========================================="
          echo "Current day: $DAY_OF_WEEK (1=Mon, 7=Sun)"
          echo "Date: $(date +'%A, %B %d, %Y %H:%M UTC')"
          
          if [ $DAY_OF_WEEK -eq 6 ] || [ $DAY_OF_WEEK -eq 7 ]; then
            echo "is_weekend=true" >> $GITHUB_OUTPUT
            echo "execution_mode=weekend_tagged_cells" >> $GITHUB_OUTPUT
            echo "üéØ MODE: WEEKEND (Tagged Cells Only)"
          else
            echo "is_weekend=false" >> $GITHUB_OUTPUT
            echo "execution_mode=weekday_full_notebook" >> $GITHUB_OUTPUT
            echo "üéØ MODE: WEEKDAY (Full Notebook)"
          fi
          echo "=========================================="

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip wheel setuptools
          pip install --no-cache-dir \
            pandas numpy requests beautifulsoup4 scikit-learn jupyter nbconvert ta nbformat

      - name: Configure Git
        run: |
          git config --global user.name "${GIT_USER_NAME}"
          git config --global user.email "${GIT_USER_EMAIL}"
          git config --global credential.helper store
          echo "https://${GITHUB_USERNAME}:${FOREX_PAT}@github.com" > ~/.git-credentials

      - name: Verify data files exist (WEEKEND ONLY)
        if: steps.detect_mode.outputs.is_weekend == 'true'
        run: |
          echo "=========================================="
          echo "VERIFYING DATA FILES FOR WEEKEND RUN"
          echo "=========================================="
          
          PICKLE_COUNT=$(find . -maxdepth 1 -name "*_2244.pkl" -type f 2>/dev/null | wc -l)
          
          if [ $PICKLE_COUNT -lt 4 ]; then
            echo "‚ùå ERROR: Only $PICKLE_COUNT/4 pickle files found"
            echo "Weekend mode requires existing data files!"
            echo ""
            echo "Available files:"
            ls -lh *.pkl 2>/dev/null || echo "No pickle files found"
            echo ""
            echo "üí° TIP: Run the workflow on a weekday first to generate data files"
            exit 1
          fi
          
          echo "‚úÖ Found all required data files ($PICKLE_COUNT)"
          echo "Files:"
          ls -lh *_2244.pkl
          echo "=========================================="

      - name: Run Tagged Cells Only (WEEKEND ONLY)
        if: steps.detect_mode.outputs.is_weekend == 'true'
        run: |
          echo "=========================================="
          echo "üè∑Ô∏è  RUNNING TAGGED CELLS ONLY"
          echo "=========================================="
          echo "Mode: ${{ steps.detect_mode.outputs.execution_mode }}"
          echo ""
          
          # Check if notebook exists
          NOTEBOOK_FILE=""
          if [ -f "AI_Forex_Brain_2.ipynb" ]; then
            NOTEBOOK_FILE="AI_Forex_Brain_2.ipynb"
          elif [ -f "AI_Forex_Brain.ipynb" ]; then
            NOTEBOOK_FILE="AI_Forex_Brain.ipynb"
          elif [ -f "forex_brain.ipynb" ]; then
            NOTEBOOK_FILE="forex_brain.ipynb"
          fi
          
          if [ -z "$NOTEBOOK_FILE" ]; then
            echo "‚ùå ERROR: No notebook file found!"
            echo ""
            echo "Looking for one of:"
            echo "  - AI_Forex_Brain_2.ipynb"
            echo "  - AI_Forex_Brain.ipynb"
            echo "  - forex_brain.ipynb"
            echo ""
            echo "Available notebooks:"
            ls -lh *.ipynb 2>/dev/null || echo "No Jupyter notebooks found"
            exit 1
          fi
          
          echo "‚úÖ Found: $NOTEBOOK_FILE"
          echo ""
          
          # Create Python script to extract and run tagged cells
          cat > run_tagged_cells.py << 'EOFPYTHON'
          import nbformat
          from nbconvert.preprocessors import ExecutePreprocessor, CellExecutionError
          import sys
          import re
          import traceback
          
          def run_tagged_cells(notebook_path, tags=['weekend', 'pipeline_main', 'v85']):
              """Execute only cells with specified tags"""
              print(f"üìñ Reading notebook: {notebook_path}")
              
              # Read the notebook
              with open(notebook_path, 'r', encoding='utf-8') as f:
                  nb = nbformat.read(f, as_version=4)
              
              print(f"‚úÖ Loaded {len(nb.cells)} total cells")
              print()
              
              # Find tagged cells
              tagged_cells = []
              for idx, cell in enumerate(nb.cells):
                  if cell.cell_type != 'code':
                      continue
                  
                  # Check metadata tags
                  cell_tags = cell.get('metadata', {}).get('tags', [])
                  
                  # Check for comment markers
                  has_comment_marker = False
                  for tag in tags:
                      if f"# TAG: {tag}" in cell.source or f"# @{tag}" in cell.source:
                          has_comment_marker = True
                          break
                  
                  # If cell has any of our target tags
                  if any(tag in cell_tags for tag in tags) or has_comment_marker:
                      tagged_cells.append((idx, cell))
                      matching_tags = [t for t in tags if t in cell_tags or f"# TAG: {t}" in cell.source or f"# @{t}" in cell.source]
                      print(f"  ‚úÖ Cell {idx}: Found tags {matching_tags}")
                      preview = cell.source[:100].replace('\n', ' ')
                      print(f"     Preview: {preview}...")
                      print()
              
              if not tagged_cells:
                  print("‚ùå ERROR: No tagged cells found!")
                  print()
                  print(f"Looking for cells with tags: {tags}")
                  print()
                  print("Available tags in notebook:")
                  for idx, cell in enumerate(nb.cells):
                      if cell.cell_type == 'code':
                          cell_tags = cell.get('metadata', {}).get('tags', [])
                          if cell_tags:
                              print(f"  Cell {idx}: {cell_tags}")
                          # Check for comment markers
                          if '# TAG:' in cell.source or '# @' in cell.source:
                              markers = re.findall(r'# TAG: (\w+)|# @(\w+)', cell.source)
                              if markers:
                                  print(f"  Cell {idx}: {[m for m in markers[0] if m]} (comment marker)")
                  print()
                  print("üí° TIP: Add tags to cells in Jupyter:")
                  print("   1. Select cell")
                  print("   2. View ‚Üí Cell Toolbar ‚Üí Tags")
                  print("   3. Add tag: 'weekend' or 'pipeline_main'")
                  print()
                  print("   OR add comment marker at top of cell:")
                  print("   # TAG: weekend")
                  return False
              
              print(f"üéØ Found {len(tagged_cells)} tagged cells to execute")
              print("=" * 60)
              print()
              
              # Execute tagged cells
              ep = ExecutePreprocessor(
                  timeout=1200,  # 20 minutes per cell
                  kernel_name='python3',
                  allow_errors=False
              )
              
              success_count = 0
              for idx, (cell_idx, cell) in enumerate(tagged_cells):
                  print(f"‚ñ∂Ô∏è  Executing cell {idx + 1}/{len(tagged_cells)} (original cell {cell_idx})...")
                  
                  try:
                      # Create a temporary notebook with just this cell
                      temp_nb = nbformat.v4.new_notebook()
                      temp_nb.cells = [cell]
                      
                      # Execute it
                      ep.preprocess(temp_nb, {'metadata': {'path': '.'}})
                      
                      print(f"   ‚úÖ Cell {cell_idx} executed successfully")
                      print()
                      success_count += 1
                      
                  except CellExecutionError as e:
                      print(f"   ‚ùå ERROR in cell {cell_idx}!")
                      print(f"   Error type: CellExecutionError")
                      print(f"   Error message: {str(e)}")
                      print()
                      print("   Full traceback:")
                      print(traceback.format_exc())
                      print()
                      print("   Cell source (first 500 chars):")
                      print(cell.source[:500])
                      print()
                      return False
                  
                  except Exception as e:
                      print(f"   ‚ùå UNEXPECTED ERROR in cell {cell_idx}!")
                      print(f"   Error type: {type(e).__name__}")
                      print(f"   Error message: {str(e)}")
                      print()
                      print("   Full traceback:")
                      print(traceback.format_exc())
                      print()
                      print("   Cell source (first 500 chars):")
                      print(cell.source[:500])
                      print()
                      return False
              
              print("=" * 60)
              print(f"‚úÖ Successfully executed {success_count}/{len(tagged_cells)} tagged cells")
              return True
          
          if __name__ == "__main__":
              notebook = sys.argv[1] if len(sys.argv) > 1 else "AI_Forex_Brain_2.ipynb"
              
              # Tags to look for (in order of priority)
              tags = ['weekend', 'pipeline_main', 'v85', 'saturday', 'sunday']
              
              success = run_tagged_cells(notebook, tags)
              sys.exit(0 if success else 1)
          EOFPYTHON
          
          echo "üîß Created tagged cell executor script"
          echo ""
          
          # Execute tagged cells with full output
          python run_tagged_cells.py "$NOTEBOOK_FILE" 2>&1 | tee weekend_execution.log
          
          EXIT_CODE=${PIPESTATUS[0]}
          if [ $EXIT_CODE -ne 0 ]; then
            echo ""
            echo "‚ùå Tagged cell execution failed with exit code $EXIT_CODE"
            echo ""
            echo "Full output log:"
            cat weekend_execution.log
            exit $EXIT_CODE
          fi
          
          echo ""
          echo "‚úÖ Tagged cells executed successfully"
        timeout-minutes: 25

      - name: Run Full Notebook (WEEKDAY ONLY - Monday to Friday)
        if: steps.detect_mode.outputs.is_weekend == 'false'
        run: |
          echo "=========================================="
          echo "üìì RUNNING FULL NOTEBOOK"
          echo "=========================================="
          echo "Mode: ${{ steps.detect_mode.outputs.execution_mode }}"
          echo "Day: $(date +'%A')"
          echo ""
          
          # Check if notebook exists
          NOTEBOOK_FILE=""
          if [ -f "AI_Forex_Brain_2.ipynb" ]; then
            NOTEBOOK_FILE="AI_Forex_Brain_2.ipynb"
          elif [ -f "AI_Forex_Brain.ipynb" ]; then
            NOTEBOOK_FILE="AI_Forex_Brain.ipynb"
          elif [ -f "forex_brain.ipynb" ]; then
            NOTEBOOK_FILE="forex_brain.ipynb"
          fi
          
          if [ -z "$NOTEBOOK_FILE" ]; then
            echo "‚ùå ERROR: No notebook file found!"
            exit 1
          fi
          
          echo "‚úÖ Found: $NOTEBOOK_FILE"
          echo ""
          
          # Execute the full notebook
          jupyter nbconvert --to notebook --execute "$NOTEBOOK_FILE" \
            --ExecutePreprocessor.timeout=2400 \
            --output="${NOTEBOOK_FILE%.ipynb}_executed.ipynb" 2>&1 | tee notebook_execution.log
          
          EXIT_CODE=${PIPESTATUS[0]}
          if [ $EXIT_CODE -ne 0 ]; then
            echo "‚ùå Notebook execution failed"
            cat notebook_execution.log
            exit $EXIT_CODE
          fi
          
          echo "‚úÖ Full notebook executed successfully"
        timeout-minutes: 50

      - name: Verify output files
        if: always()
        run: |
          echo "=========================================="
          echo "üìã CHECKING OUTPUT FILES"
          echo "=========================================="
          
          # Check for pickle files
          echo "Pickle files:"
          if ls *_2244.pkl 1> /dev/null 2>&1; then
            ls -lh *_2244.pkl
          else
            echo "  ‚ö†Ô∏è  No pickle files found"
          fi
          echo ""
          
          # Check for signal files
          echo "Signal files:"
          for file in broker_signals.json ensemble_signals.json; do
            if [ -f "$file" ]; then
              FILE_SIZE=$(wc -c < "$file")
              echo "  ‚úÖ $file (${FILE_SIZE} bytes)"
            else
              echo "  ‚ö†Ô∏è  $file not found"
            fi
          done
          echo ""
          
          # Check for learning files
          echo "Learning files:"
          for file in learning_v85.pkl iteration_v85.pkl memory_v85.db; do
            if [ -f "$file" ]; then
              FILE_SIZE=$(wc -c < "$file")
              echo "  ‚úÖ $file (${FILE_SIZE} bytes)"
            else
              echo "  ‚ö†Ô∏è  $file not found"
            fi
          done
          echo "=========================================="

      - name: Commit and push changes
        if: always()
        run: |
          git add -A
          
          if git diff --cached --quiet; then
            echo "‚ÑπÔ∏è  No changes to commit"
          else
            MODE="${{ steps.detect_mode.outputs.execution_mode }}"
            TIMESTAMP=$(date +'%Y-%m-%d %H:%M:%S UTC')
            DAY=$(date +'%A')
            
            git commit -m "ü§ñ Auto-update [$MODE] - $DAY: $TIMESTAMP" || true
            
            echo "Syncing with remote..."
            for i in {1..3}; do
              echo "Attempt $i: Pulling latest changes..."
              if git pull --rebase origin main 2>&1 | grep -q "CONFLICT"; then
                echo "‚ö†Ô∏è  Conflict detected, resolving with ours strategy..."
                git checkout --ours .
                git add -A
                git rebase --continue || true
              fi
              
              echo "Attempt $i: Pushing to GitHub..."
              if git push origin main 2>&1; then
                echo "‚úÖ Successfully pushed on attempt $i"
                break
              else
                echo "‚ö†Ô∏è  Push failed on attempt $i"
                if [ $i -lt 3 ]; then
                  sleep 3
                  git fetch origin main
                  git reset --soft origin/main
                  git add -A
                  git commit -m "ü§ñ Auto-update [$MODE] - $DAY: $TIMESTAMP" || true
                fi
              fi
            done
          fi

      - name: Upload logs and artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pipeline-logs-${{ github.run_number }}
          path: |
            weekend_execution.log
            notebook_execution.log
            *_executed.ipynb
            forex_pipeline_v85.log
            pipeline.log
          retention-days: 7
          if-no-files-found: ignore

      - name: Summary
        if: always()
        run: |
          echo "=========================================="
          echo "üìä EXECUTION SUMMARY"
          echo "=========================================="
          echo "Mode: ${{ steps.detect_mode.outputs.execution_mode }}"
          echo "Weekend: ${{ steps.detect_mode.outputs.is_weekend }}"
          echo "Day: $(date +'%A')"
          echo "Date: $(date +'%B %d, %Y %H:%M UTC')"
          echo ""
          echo "Generated Files:"
          
          for file in broker_signals.json ensemble_signals.json learning_v85.pkl iteration_v85.pkl memory_v85.db; do
            if [ -f "$file" ]; then
              FILE_SIZE=$(wc -c < "$file" 2>/dev/null || echo "0")
              echo "  ‚úÖ $file (${FILE_SIZE} bytes)"
            fi
          done
          
          PICKLE_COUNT=$(find . -maxdepth 1 -name "*_2244.pkl" -type f 2>/dev/null | wc -l)
          if [ $PICKLE_COUNT -gt 0 ]; then
            echo "  ‚úÖ ${PICKLE_COUNT} pickle data files"
          fi
          
          echo "=========================================="
